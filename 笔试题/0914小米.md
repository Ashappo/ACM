[TOC]

### 一、选择：

#### 1.

#### 2.哪个文件操作不会影响文件偏移？

A.truncate("text.txt",20);

B.lseek(fd,10,SEEK_SET);

C.read(fd,buf,3);

D.write(df,buf,3);

#### 3.编译程序的工作过程一般可以划分为哪5个基本阶段，还自始至终伴随进行哪两项工作？

Ans：

1、编译程序把一个==源程序翻译成目标程序==的工作过程分为==五个阶段：词法分析；语法分析；中间代码生成；代码优化；目标代码生成==。

2、编译程序的工作过程一般==自始至终伴随==进行信息表管理和==出错处理==两项工作。

主要是进行词法分析和语法分析，又称为源程序分析，分析过程中发现有语法错误，给出提示信息。

[![img](E:\笔记\图片库\e7cd7b899e510fb3545c39e9c933c895d1430c02.png)](https://iknow-pic.cdn.bcebos.com/e7cd7b899e510fb3545c39e9c933c895d1430c02)

**扩展资料：**

解释程序是一种语言处理程序，在词法、语法和语义分析方面与编译程序的工作原理基本相同，但在运行用户程序时，它直接执行源程序或源程序的内部形式(中间代码)。因此，解释程序并不产生目标程序，这是它和编译程序的主要区别。解释程序的工作过程如下：

1、由总控程序完成初始化工作。

2、依次从源程序中取出一条语句进行语法检查，如有错，输出错误信息；如果通过了语法检查，则根据语句翻泽成相应的指令并执行它。

3、检查源程序是否已经全部解释执行完毕，如果未完成则继续解释并执行下一条语句，直到全部语句都处理完毕。

#### 4.二叉树前序为ABDEGCFH(NLR)、后序为DGEBHFCA(LRN)，求中序可能是？

A.DBGEACHF

B.DGCHBEFA

C.DGBHCFA

D.DBGEHCFA

### 二、多选：

#### 1.

> A.跳表常用于有序表：
>
> 增加了向前指针的链表叫作跳表。跳表全称叫做跳跃表，简称跳表。跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。
>
> 跳表是一个有序的数据结构，它通过内部节点维护的一个指向其他节点的指针，从而达到快速访问的目的。
>
> 跳表支持平均时间复杂度为o(logn)的增删查改，最坏的时间复杂度为o(N)
>
> 跳表和平衡二叉树的区别：
>
> 1. 跳表实现步骤相对平衡二叉树来说相对简单一些。
>
> 2.跳表和二叉树都是有序存储的数据结构，他们的查找时间复杂度都是logN。
>
> 3.平衡二叉树每次增删节点都需要检查是否需要reblance从而使树达到平衡，而跳表在增删的时候只需要实现局部节点的指针的变化，也就是只需要改变相邻节点的指针。
>
> 4. 跳表在区间查询上要好于平衡二叉树，只需要找到起始的区间节点然后向后遍历即可，而平衡二叉树则比跳跃链表操作复杂，如果没有parent节点的话要一个一个找到。
>
> Redis 选择 跳表的原因：
>
> 1.区间查找redis 的操作要由于 平衡树。
>
> 2.跳表实现相对于二叉树比较简单
>
> 3.高并发情况下，红黑树的reblance可能涉及到整棵树，但是跳跃链表只有局部
>
> ```cpp
> edis.h/zskiplistNode
> typedef struct zskiplistNode {
> 　　　// 层
>     struct zskiplistLevel{
> 　　　　 // 前进指针
>         struct zskiplistNode *forward;
> 　　　　 // 跨度
>         unsigned int span;
>     } level[];
> 　　// 后退指针
>     struct zskiplistNode *backward;
> 　　// 分值
>     double score;
> 　　// 成员对象
>     robj *obj;
> } zskiplistNode;
>  
> level：level 数组可以包含多个元素，每个元素都包含一个指向其他节点的指针。程序可以通过这些层来加速访问其他节点。
> redis.h/zskiplist
> typedef struct zskiplist {
>      // 表头节点和表尾节点
>      structz skiplistNode *header,*tail;
>      // 表中节点数量，不包括头结点
>      unsigned long length;
>      // 表中层数最大的节点的层数，不包括头结点
>      int level;
> } zskiplist;
>  
> header， 指向跳跃表的头结点
> tail，   指向跳跃表的尾节点
> length， 记录跳跃表中节点的数量，不包含头节点
> level，  记录跳跃表中节点的最高层数，不计算头结点层数
> ```
>
> 增删查改的代码实现着重依赖于找到即将插入节点的路径 这个路径保存在一个零时的update[]数组里面，它记录了即将要插入的节点的previous的指针节点， 数组大小就是level大小，也就是随机出来的当前插入节点最高多少层。 redis中跳表层数的大小随机规则是 最下面的层的分配概率是50% 每上升一层概率减少50%，也就是第二层25%，第三层12.5%...依次次类推。
>
> 跳表中还有个属性是 在每一个 leve 数据结构中（也就是包含指向下一个节点的数据结构）有一个属性是span 通过这个属性 可以获取到 当前节点的排名， span储存了从当前节点到下一个节点中间有多少节点，这样要计算排名的话把span进行累加就可以了。
> ————————————————
> 原文链接：https://blog.csdn.net/qq_36510642/article/details/123810573

> B.堆排序属于选择排序，希尔排序属于插入排序
>
> 

#### 2.进程执行过程中，访问页不在内存会发生什么？

