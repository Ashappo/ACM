[滑雪](https://blog.csdn.net/violinlove/article/details/81270879)

题意：

Michael喜欢滑雪百这并不奇怪， 因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael想知道载一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子 ：

1  2  3  4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9


           一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可滑行的滑坡为24-17-16-1。当然25-24-23-...-3-2-1更长。事实上，这是最长的一条。

Input

输入的第一行表示区域的行数R和列数C(1 <= R,C <= 100)。下面是R行，每行有C个整数，代表高度h，0<=h<=10000。

Output

输出最长区域的长度。

Sample Input

5 5
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
Sample Output

25
————————————————

```cpp
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;
 
inline int wread(){
	char c=getchar ();int flag=1,wans=0;
	while (c<'0'||c>'9'){if (c=='-') flag=-1;c=getchar ();}
	while (c>='0'&&c<='9'){wans=wans*10+c-'0';c=getchar ();}
	return wans*=flag;
}
 
int n,m; 
int a[105][105];
int dp[106][106];
int dx[5]={0,0,1,-1};
int dy[5]={1,-1,0,0};
bool vis[105][105];
int dfs (int x,int y){
	if (dp[x][y])	return dp[x][y];
	for (int i=0; i<4; ++i){
		int xx=x+dx[i];
		int yy=y+dy[i];
		if (vis[xx][yy]==false && xx>0 && xx<=n && yy>0 && yy<=m && a[xx][yy] < a[x][y]){
			int ans=dfs(xx,yy)+1;
			dp[x][y]=max(dp[x][y],ans);
		}
	}
	return max(dp[x][y],1);
}
 
int main (){
	n=wread(),m=wread();
	for (int i=1;i<=n;++i){
		for (int j=1;j<=m;++j){
			a[i][j]=wread();
		}
	}
	int pr=0;
	for (int i=1;i<=n;++i){
		for (int j=1;j<=m;++j){
			memset (vis,false,sizeof vis);
			vis[i][j]=true;
			pr = max (pr, dfs (i,j) );
		}
	}
//	for (int i=1;i<=n;++i){
//		for (int j=1;j<=m;++j){
//			printf ("%d ",dp[i][j]);
//		}puts("");
//	}
	printf ("%d\n",pr);
	return 0;
}
```

