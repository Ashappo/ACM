https://www.acwing.com/problem/content/3310/

Isyana 获得了其当地主题公园连续 NN 天的游客人数。

其中第 ii 天的游客人数为 ViVi。

如果某天能够同时满足以下两个条件，则这一天被视为破纪录的一天：

1. 这一天的游客人数严格大于以前每一天的游客人数。
2. 这是最后一天，或者这一天的游客人数严格大于下一天的游客人数。

请注意，第一天也可以是破纪录的一天。

请帮助 Isyana 找出破纪录的天数。

#### 输入格式

第一行包含整数 TT，表示共有 TT 组测试数据。

每组数据第一行包含整数 NN。

第二行包含 NN 个整数，其中第 ii 个表示 ViVi。

#### 输出格式

每组数据输出一个结果，每个结果占一行。

结果表示为 `Case #x: y`，其中 xx 为组别编号（从 11 开始），yy 为破纪录的天数。

#### 数据范围

1≤T≤1001≤T≤100,
0≤Vi≤2×1050≤Vi≤2×105,
对于每个测试点，满足 1≤N≤2×1051≤N≤2×105 的数据一定不超过 1010 组，其余数据则满足 1≤N≤10001≤N≤1000。

#### 输入样例：

```
4
8
1 2 0 7 2 0 2 0
6
4 8 15 16 23 42
9
3 1 4 1 5 9 2 6 5
6
9 9 9 9 9 9
```

#### 输出样例：

```
Case #1: 2
Case #2: 1
Case #3: 3
Case #4: 0
```

#### 样例解释

对于测试样例 11，第二天和第四天破了纪录。

对于测试样例 22，只有最后一天破了纪录。

对于测试样例 33，第一天、第三天和第六天破了纪录。

对于测试样例 44，没有一天破了纪录。

```
#注意样例 2+4，从小到大，相同元素，如果不对首位或者最后一位特殊处理，会有问题
#if(nums[i] > maxn && (i == m - 1 || nums[i] > nums[i + 1]))//包含了最后一位的特殊情况
#在外面maxn= max(maxn, nums[i])，节省判断
#include<bits/stdc++.h>
using namespace std;

int main()
{   int n, x = 0;
    cin>>n;
    while (n -- ){
        int m, ans = 0;
        x++;
        cin>>m;
        vector<int> nums(m);
        for (int i = 0; i < m; i ++ ) cin>>nums[i];
        int maxn = 0;
        for (int i = 0; i < m; i ++ ){
            if(nums[i] > maxn && (i == m - 1 || nums[i] > nums[i + 1])){//pac
                ans++;
            }
            maxn = max(maxn, nums[i]);//pac 在外面，不论是否变化，都进行一次判断，如果在if内部变化，那么相同元素maxn值不会变化，在外面可以省去特殊情况的判断
        }
        cout<<"Case #"<<x<<": "<<ans<<endl;//Case #1: 2
    }
    return 0;
}
```

