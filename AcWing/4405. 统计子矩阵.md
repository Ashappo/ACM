> https://www.acwing.com/problem/content/4408/
>
> 给定一个 N×MN×M 的矩阵 AA，请你统计有多少个子矩阵 (最小 1×11×1，最大 N×MN×M) 满足子矩阵中所有数的和不超过给定的整数 KK?
>
> #### 输入格式
>
> 第一行包含三个整数 N,MN,M 和 KK。
>
> 之后 NN 行每行包含 MM 个整数，代表矩阵 AA。
>
> #### 输出格式
>
> 一个整数代表答案。
>
> #### 数据范围
>
> 对于 30%30% 的数据，N,M≤20N,M≤20，
> 对于 70%70% 的数据，N,M≤100N,M≤100，
> 对于 100%100% 的数据，1≤N,M≤500;0≤Aij≤1000;1≤K≤2500000001≤N,M≤500;0≤Aij≤1000;1≤K≤250000000。
>
> #### 输入样例：
>
> ```
> 3 4 10
> 1 2 3 4
> 5 6 7 8
> 9 10 11 12
> ```
>
> #### 输出样例：
>
> ```
> 19
> ```
>
> #### 样例解释
>
> 满足条件的子矩阵一共有 1919，包含：
>
> - 大小为 1×11×1 的有 1010 个。
> - 大小为 1×21×2 的有 33 个。
> - 大小为 1×31×3 的有 22 个。
> - 大小为 1×41×4 的有 11 个。
> - 大小为 2×12×1 的有 33 个。

```cpp
#暴力解一定超时
#include<bits/stdc++.h>
using namespace std;
const int N = 505;
int a[N][N];
typedef long long LL;
int main(){   
    ios::sync_with_stdio(false);cin.tie(0);//pac
    int n,m,k;
    LL ans = 0;
    cin>>n>>m>>k;
    for(int i = 1; i <= n; i++){//在边届旁边的数组值初始化时已为0，不用管
        for(int j = 1; j <= m; j++){
            cin>>a[i][j];
            a[i][j] +=a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1];//用a[i][j]存储从a[1][1]->a[i][j]的矩阵内所有元素和。(- a[i - 1][j - 1]消除重复值)
        }
    }
    for(int i = 1; i <= m; i++){//i从1开始遍历，j从i遍历,作为左右边界
        for(int j = i; j <= m; j++){
            for(int s = 1, t = 1;t <= n; t++){//st作为上下边界，每次t++,寻找以t下界为底是否存在满足条件的矩阵
                while(s <= t && a[t][j] - a[t][i - 1] - a[s - 1][j] + a[s - 1][i - 1] > k)      s++;//pac这里要的是从左上角a[s][i]到右下角a[t][j]的矩阵值，
                //那么我们应当减去对应的左下角a[t][i]左侧的a[t][i - 1]和右上角a[s][j]上面的a[s- 1][j]和左上角的左上方a[s - 1][i - 1]
                if(s <= t) ans += t - s + 1;//长度等于下标+1
            }
        }
    }
    cout<<ans<<'\n';
    
    return 0;
}

```

